# PROPUESTA INCIAL

## TABLAS

🏛️ Modelo de Datos Adaptado: Gestor de Comunidades
👥 Tabla: users (Usuarios)
id → Identificador único
email → Email del usuario
name → Nombre completo
created_at → Fecha de registro
updated_at → Última actualización

🏡 Tabla: communities (Comunidades)
id → Identificador único
name → Nombre de la comunidad (ej: "Comunidad C/Mayor, 5")
address → Dirección de la comunidad
created_at → Fecha de creación

🔗 Tabla: user_communities (Tabla de relación)
user_id → Conecta con users.id
community_id → Conecta con communities.id
role → Rol del usuario en la comunidad ("administrador", "residente", etc.)

📄 Tabla: documents (Documentos)
id → Identificador único
community_id → Conecta con communities.id (¡Importante!)
filename → Nombre original del archivo
file_path → Dónde está guardado
file_size → Tamaño en bytes
file_hash → Hash del contenido del archivo (para detectar duplicados)
document_type → "acta", "factura", "comunicado", "contrato", "presupuesto"
status → "processing", "completed", "error"
created_at → Cuándo se subió
processed_at → Cuándo terminó el procesamiento

📊 Tablas de Datos Específicos
📄 Tabla: extracted_minutes (Datos de Actas)
id → Identificador único
document_id → Conecta con documents.id
president_in → Nombre del presidente entrante
president_out → Nombre del presidente saliente
administrator → Nombre del administrador
summary → Resumen del acta
decisions → Decisiones tomadas (JSON o texto)

💰 Tabla: extracted_invoices (Datos de Facturas)
id → Identificador único
document_id → Conecta con documents.id
provider_name → Nombre del proveedor
client_name → Nombre del cliente
amount → Importe
invoice_date → Fecha de la factura
category → Categoría (ej: "electricidad", "mantenimiento")

📜 Tabla: extracted_contracts (Datos de Contratos)
id → Identificador único
document_id → Conecta con documents.id
contract_party → Nombre de la parte contratada (ej. "Proveedor de servicios X")
start_date → Fecha de inicio del contrato
end_date → Fecha de finalización del contrato
amount → Importe total o periódico del contrato
summary → Resumen de las cláusulas clave

📢 Tabla: extracted_communications (Datos de Comunicados)
id → Identificador único
document_id → Conecta con documents.id
subject → Asunto o título del comunicado
sent_date → Fecha de envío del comunicado
recipient_type → Tipo de destinatario ("todos los vecinos", "sólo administradores", etc.)
content_summary → Resumen del contenido del comunicado

💸 Tabla: extracted_budgets (Datos de Presupuestos)
id → Identificador único
document_id → Conecta con documents.id
budget_year → Año del presupuesto
total_income → Ingresos totales
total_expenses → Gastos totales
approved_date → Fecha de aprobación del presupuesto
breakdown → Desglose detallado por categorías (JSON o texto)

🤖 Tabla: agents (Agentes de IA)
id → Identificador único
name → Nombre del agente (ej. "Lector de Actas", "Identificador de Preguntas")
purpose → Descripción de la función del agente
prompt_template → El texto base o "instrucción" que se le da a la IA
variables → Variables que el agente necesita para funcionar (JSON)
created_at → Cuándo se creó el registro

🎯 Tabla: vector_embeddings (Para búsqueda semántica)
id → Identificador único
document_id → Conecta con documents.id
content → Texto del chunk
embedding → Vector numérico
created_at → Cuándo se creó

## PORCESOS

📝 Procesos de Negocio
Proceso 1: Ingesta de Documentos
Selección de Comunidad: El usuario selecciona una comunidad (community_id) a través de la interfaz.

Subida y Verificación: El usuario sube un archivo y el sistema genera su hash. Se comprueba en la tabla documents si el archivo (file_hash) ya existe para esa comunidad.

Validación de Duplicados: Si el archivo ya existe, el proceso se detiene y se notifica al usuario.

Extracción de Texto: El sistema lee el documento y extrae su contenido de texto (document_text).

Identificación de Tipo: Si no es un duplicado, el Agente de Identificación de Documento lee el texto extraído (document_text) y clasifica el archivo basándose en este para determinar su document_type ("acta", "factura", etc.).

Extracción de Datos: El agente lector adecuado (ej. el Lector de Actas o el Lector de Facturas) lee el contenido y extrae la información relevante. Los datos se usan para rellenar la tabla documents y la tabla específica correspondiente.

Chunking y Embedding: El documento (document_text) es dividido en fragmentos de 800 tokens (content). Cada fragmento se convierte en un vector numérico (embedding) y se guarda en la tabla vector_embeddings, asociado al document_id.

Proceso 2: Consulta de Datos Estructurados
Consulta de Documentos: El usuario puede listar los documentos disponibles de una comunidad específica. La consulta se realiza sobre la tabla documents filtrando por community_id.

Consulta por Tipo: Se filtra aún más la consulta por document_type (ej. "actas").

Consulta de Comunidades: El usuario puede ver todas las comunidades disponibles asociadas a su perfil (tabla user_communities).

Consulta de Datos Específicos: El usuario realiza una consulta sobre los datos extraídos (ej. ¿quién fue el presidente del acta?) que se resuelve con una consulta a las tablas de datos específicos (ej. extracted_minutes).

Proceso 3: Gestión de Comunidades
Creación de Comunidad: El usuario (con el rol adecuado) crea un nuevo registro en la tabla communities.

Asociación de Usuario: Se crea un registro en la tabla user_communities para vincular al usuario que la creó.

Proceso 4: Búsqueda Semántica
Consulta Semántica: El usuario introduce una pregunta de lenguaje natural (ej. ¿Qué se ha gastado en el mantenimiento del jardín el último año?), esta variable se llama pregunta.

Análisis de la Pregunta: El Agente de Análisis de Preguntas es responsable de analizar la pregunta para identificar campos obligatorios (como community), y opcionales (como document_type y rango temporal), estando sesgado a dar la respuesta con la fecha más reciente si no se menciona un dato temporal.

Mejora de la Pregunta: La pregunta es enriquecida con los datos recopilados por el Agente de Análisis de Preguntas antes de la vectorización. La variable resultante se llama pregunta_enriquecida.

Vectorización: La pregunta_enriquecida se convierte en un vector numérico. La variable resultante se llama embedding_pregunta.

Búsqueda y Recuperación: El Agente de Recuperación de Datos busca los embeddings más similares a embedding_pregunta en la tabla vector_embeddings, aplicando los filtros identificados. Los resultados se guardan en la variable chunks_relevantes.

Generación de Respuesta: La información recuperada en chunks_relevantes se pasa al Agente de Conversación, que genera una respuesta final para el usuario.

Proceso 5: Consulta a través del Chat
Inicio de Conversación: El usuario hace una pregunta al chat. La variable se llama pregunta.

Análisis de la Pregunta: El Agente de Análisis de Preguntas analiza la pregunta, identifica si la respuesta podría estar en la base de datos estructurada y extrae los filtros necesarios (comunidad, tipo de documento, etc.). Los hallazgos se guardan en la variable analisis_pregunta.

Mejora de la Pregunta: La pregunta es enriquecida con los datos recopilados por el Agente de Análisis de Preguntas. La variable resultante se llama pregunta_enriquecida.

Búsqueda de Datos Estructurados: El sistema hace una consulta a la base de datos estructurada con los filtros de analisis_pregunta. Si se encuentra la información, se recupera. La variable se llama datos_estructurados.

Búsqueda Semántica (si es necesario): Si los datos no se encontraron en el paso anterior o la pregunta requiere una búsqueda semántica, el Agente de Recuperación de Datos busca los 20 chunks más relevantes en la tabla vector_embeddings, aplicando los filtros de analisis_pregunta. Los resultados se guardan en la variable chunks_relevantes.

Combinación de Datos: La información recuperada (tanto los datos_estructurados como los chunks_relevantes) se combina para crear un contexto completo. La variable se llama contexto_completo.

Generación de Respuesta: El Agente de Conversación toma el contexto_completo y la pregunta_enriquecida original del usuario para generar una respuesta coherente y amigable. La variable se llama respuesta_final.

## AGENTES

Definición de Agentes y sus Prompts
A continuación, se define la configuración de cada agente para la tabla agents.

1. Agente de Identificación de Documento
   Propósito: Analizar un documento para determinar su tipo (acta, factura, comunicado, contrato, presupuesto) y clasificarlo en consecuencia.

prompt_template:

Eres un clasificador de documentos para una comunidad de propietarios. Tu tarea es analizar el texto de un documento y clasificarlo en una de las siguientes categorías: 'acta', 'factura', 'comunicado', 'contrato' o 'presupuesto'. Devuelve únicamente el nombre de la categoría, sin explicaciones ni texto adicional.

Texto del documento: {document_text}

variables:

{
"input_key": "document_text",
"output_type": "string"
}

2. Agente Lector de Actas
   Propósito: Extraer los datos estructurados clave de un acta de comunidad para rellenar la tabla extracted_minutes.

prompt_template:

Eres un asistente experto en analizar actas de comunidades. Extrae la siguiente información del texto proporcionado, devolviéndola en un formato JSON estricto: presidente entrante, presidente saliente, administrador, un resumen conciso y un listado de las decisiones tomadas.

Texto del acta: {document_text}

variables:

{
"input_key": "document_text",
"output_format": "json"
}

3. Agente Lector de Facturas
   Propósito: Extraer los datos estructurados clave de una factura para rellenar la tabla extracted_invoices.

prompt_template:

Eres un asistente que lee facturas. Extrae los siguientes datos del texto, devolviéndolos en formato JSON: nombre del proveedor, nombre del cliente, importe total, fecha de la factura y categoría de gasto (por ejemplo, 'electricidad'). Si algún dato no se encuentra, usa null.

Texto de la factura: {document_text}

variables:

{
"input_key": "document_text",
"output_format": "json"
}

4. Agente Lector de Contratos
   Propósito: Extraer los datos estructurados clave de un contrato para rellenar la tabla extracted_contracts.

prompt_template:

Eres un asistente que lee contratos. Extrae los siguientes datos del texto, devolviéndolos en formato JSON: nombre de la parte contratada, fecha de inicio y finalización del contrato, importe total o periódico, y un resumen de las cláusulas. Si algún dato no se encuentra, usa null.

Texto del contrato: {document_text}

variables:

{
"input_key": "document_text",
"output_format": "json"
}

5. Agente Lector de Comunicados
   Propósito: Extraer los datos estructurados clave de un comunicado para rellenar la tabla extracted_communications.

prompt_template:

Eres un asistente que lee comunicados. Extrae los siguientes datos del texto, devolviéndolos en formato JSON: el asunto, la fecha de envío, el tipo de destinatario ('todos los vecinos', 'sólo administradores', etc.), y un resumen conciso del contenido. Si algún dato no se encuentra, usa null.

Texto del comunicado: {document_text}

variables:

{
"input_key": "document_text",
"output_format": "json"
}

6. Agente Lector de Presupuestos
   Propósito: Extraer los datos estructurados clave de un presupuesto para rellenar la tabla extracted_budgets.

prompt_template:

Eres un asistente que lee presupuestos. Extrae los siguientes datos del texto, devolviéndolos en formato JSON: año del presupuesto, total de ingresos, total de gastos, fecha de aprobación y un desglose detallado. Si algún dato no se encuentra, usa null.

Texto del presupuesto: {document_text}

variables:

{
"input_key": "document_text",
"output_format": "json"
}

7. Agente de Análisis de Preguntas
   Propósito: Analizar la pregunta del usuario para identificar la intención, filtros de búsqueda y determinar si se trata de una consulta de datos estructurados o una búsqueda semántica.

prompt_template:

Eres un agente especializado en entender preguntas de lenguaje natural y convertirlas en parámetros de búsqueda. Analiza la siguiente pregunta para identificar: 1) si la pregunta requiere datos estructurados (por ejemplo, 'presidente del acta'), 2) si se puede responder con una búsqueda semántica (ej. '¿Qué se decidió sobre el tejado?'), 3) el tipo de documento ('acta', 'factura', etc.) si se menciona, y 4) el rango de tiempo si se menciona ('último año'). Devuelve un JSON con tus hallazgos.

Pregunta: {user_query}

variables:

{
"input_key": "user_query",
"output_format": "json"
}

8. Agente de Recuperación de Datos
   Propósito: Buscar y recuperar la información relevante de las tablas (vector_embeddings y otras tablas de datos estructurados) utilizando una estrategia de búsqueda híbrida (keyword + semántica) y un sistema de ranking Top K, aplicando los filtros y el embedding de la pregunta proporcionados.

prompt_template:

Eres un motor de búsqueda y recuperación. Tu tarea es recuperar los datos más relevantes para responder una pregunta, basándote en la consulta vectorizada y los filtros proporcionados. Si la búsqueda es semántica, recupera los fragmentos de texto más similares. Si es una consulta estructurada, recupera los datos de las tablas correspondientes.

Información de la consulta: {search_query}

variables:

{
"input_key": "search_query",
"output_format": "json"
}

9. Agente de Conversación
   Propósito: Generar una respuesta coherente y conversacional para el usuario, usando la información estructurada o los fragmentos de texto (chunks) recuperados de la base de datos.

prompt_template:

Eres un asistente conversacional para un gestor de comunidades. Tu tarea es responder a las preguntas de los usuarios de forma clara y amigable, utilizando la siguiente información recuperada de la base de datos. Si la información no es suficiente, indícalo.

Información recuperada: {retrieved_data}
Pregunta del usuario: {pregunta_enriquecida}

variables:

{
"input_keys": ["retrieved_data", "pregunta_enriquecida"],
"output_format": "string"
}

# COMENTARIOS

🎯 Excelente arquitectura - Como arquitecto, veo un diseño muy sólido. Te doy mi análisis y recomendación de
implementación:

📊 Mi Evaluación como Arquitecto

✅ Fortalezas del Diseño

1. Separación clara: Documentos vs datos extraídos
2. Escalabilidad: Vector embeddings + datos estructurados
3. Multi-tenancy: Todo vinculado a community_id
4. Flexibilidad: Sistema de agentes configurable

⚠️ Puntos de Mejora

1. user_communities duplica user_roles - Ya tienes este sistema
2. Complejidad inicial - 12+ tablas es mucho para empezar

🚀 Mi Recomendación: Implementación Incremental

# VALIDACION

¿Cómo validar cada fase?

FASE → Implementar → Probar con usuarios reales → Iterar → Siguiente fase

# multi-tenancy

🏗️ Arquitectura Multi-tenant Correcta

Tienes razón - el diseño actual no es óptimo. Para un SaaS real necesitas:

🎯 Estructura Correcta:

ORGANIZATION (Administrador de Fincas)
├── COMMUNITY 1
│ ├── Vecino A, Vecino B, Vecino C
│ └── Proveedor X, Proveedor Y
├── COMMUNITY 2
│ ├── Vecino D, Vecino E
│ └── Proveedor Z
└── COMMUNITY 3
└── ...

🚫 MALO - Tablas por tenant:

-- ❌ Esto NO escala y es pesadilla de mantenimiento
communities_admin1
communities_admin2
users_admin1
users_admin2

✅ BUENO - Single Database Multi-tenant:

-- ✅ Todas las tablas compartidas con tenant_id
organizations (admin de fincas)
├── communities (organization_id)
├── users (organization_id)
├── incidents (organization_id, community_id)
└── documents (organization_id, community_id)

🎯 Ventajas:

1. ✅ Escalabilidad: Una BD para miles de administradoras
2. ✅ Isolation: Cada admin solo ve sus datos
3. ✅ Cost-effective: No duplicar infraestructura
4. ✅ Maintenance: Una sola versión de código
5. ✅ Analytics: Datos agregados posibles

# HABILITAR AGENTE DE BASE DE DATOS

## MCP SUPABASE

- Donde esta -->
- el MCP \\wsl.localhost\Ubuntu\home\sergi\proyectos\community-saas\.mcp.json
- .config/claude/claude_desktop_config.json

Configuración está correcta:

- Server: @modelcontextprotocol/server-postgres
- DATABASE_URL: Conecta directamente a tu Supabase PostgreSQL
- Credentials: Incluye usuario postgres y contraseña

## CREAR EL AGENTE

- en CLI mirar `/agents` .claude\dbmaster-supabase.json

# 🎯 Siguiente Paso: DEPLOY

¿Por qué deploy primero?

1. Validar Arquitectura Real

- Tu multi-tenancy con organizations está implementado ✅
- Sistema de permisos funciona ✅
- Base sólida probada en local ✅
- Necesitas validar en producción ANTES de añadir complejidad

2. Feedback Loop Temprano

- Los usuarios reales te dirán qué necesitan
- Puedes iterar rápidamente sobre funcionalidad básica
- Evitas sobreingeniería prematura

3. Fundación Sólida

- Tienes un MVP funcional multi-tenant
- Adding RAG/documents sobre una base inestable = problema
- Deploy exitoso = confianza para siguientes features

🚀 Plan Recomendado:

AHORA: Deploy & Validar
├── 1. Deploy a Vercel/producción
├── 2. Probar flujo completo real
├── 3. Documentar issues de producción
└── 4. Fix críticos si los hay

DESPUÉS: Iteración incremental
├── 5. Document ingestion system
├── 6. RAG/AI chat implementation
└── 7. UI/UX refinements

🎯 ¿Por qué NO empezar con documents ahora?

Tu diseño de L1.6 es brillante pero:

- 12+ tablas nuevas es gran salto
- RAG requiere vectorización estable
- Sin validar base, puedes pivotar después

🏗️ Arquitectura Incremental Correcta:

Fase Actual ✅: Organizations + Communities + Incidents
Fase 2: Documents + Basic Upload
Fase 3: AI Agents + RAG
Fase 4: Advanced UI/UX

# CREAR AGENTE DE DEPLOY
