# L1.7 - Plan Maestro: Implementaci√≥n Sistema de Gesti√≥n Documental + IA/RAG

## Resumen Ejecutivo

Este plan maestro establece la implementaci√≥n sistem√°tica de un sistema completo de gesti√≥n documental con capacidades de IA y RAG (Retrieval Augmented Generation) para la plataforma Community SaaS. La implementaci√≥n se divide en 4 fases incrementales, cada una proporcionando valor inmediato mientras construye hacia el sistema completo.

## Arquitectura del Sistema

### Stack Tecnol√≥gico

- **Frontend**: Next.js 15.3.0 + React 19.1.0 + TypeScript 5.8.3
- **Backend**: Next.js API Routes + Server Actions
- **Base de Datos**: Supabase PostgreSQL 2.49.4 + pgvector
- **Storage**: Supabase Storage para archivos
- **IA/LLM**: Google Gemini Flash 1.5 (calidad/precio √≥ptimo)
- **Vector Database**: pgvector (extensi√≥n PostgreSQL integrada)
- **UI Framework**: Tailwind CSS 4.1.3 + shadcn/ui + Radix UI
- **State Management**: React Query 4.36.1 + React Hook Form + Zod
- **Development**: ESLint + Prettier + Vitest + Playwright

### Principios Multi-tenant

- Aislamiento completo por `organization_id`
- RLS (Row Level Security) en todas las tablas
- Cuotas por organizaci√≥n (storage, tokens IA, documentos)
- Permisos granulares por comunidad y rol

## Agentes para el desarrollo del SaaS

### üîß **Agentes Claude Code (.claude/) - Para Desarrollo**

1. **dbmaster-supabase** ‚úÖ - Migraciones y optimizaci√≥n BD
2. **deployment-master** ‚úÖ - Despliegues automatizados
3. **ui-guardian** ‚úÖ - Testing workflows UI/UX
4. **vercel-master** ‚úÖ - Issues deployment Vercel
5. **architect-master** ‚úÖ - Coordinaci√≥n desarrollo

### ü§ñ **Agentes SaaS (Tabla `agents`) - Para Procesamiento**

Los agentes del SaaS procesan documentos con prompts espec√≠ficos y Gemini Flash 1.5:

```sql
-- Tabla de agentes del sistema SaaS
CREATE TABLE agents (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID REFERENCES organizations(id), -- Multi-tenant
  name TEXT NOT NULL,
  purpose TEXT NOT NULL,
  prompt_template TEXT NOT NULL,
  variables JSONB DEFAULT '{}',
  model_config JSONB DEFAULT '{
    "model": "gemini-1.5-flash",
    "temperature": 0.1,
    "max_tokens": 2048
  }',
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

#### **Agentes SaaS Necesarios:**

1. **document_classifier**

   - Clasifica PDFs en: acta, factura, comunicado, contrato, presupuesto
   - Prompt: "Analiza el texto y devuelve √∫nicamente la categor√≠a..."

2. **minutes_extractor**

   - Extrae: presidente entrante/saliente, administrador, resumen, decisiones
   - Output: JSON estructurado para tabla `extracted_minutes`

3. **invoice_extractor**

   - Extrae: proveedor, cliente, importe, fecha, categor√≠a
   - Output: JSON para tabla `extracted_invoices`

4. **query_analyzer**

   - Analiza consultas de usuarios
   - Determina: b√∫squeda sem√°ntica vs estructurada, filtros necesarios

5. **rag_responder**
   - Genera respuestas conversacionales
   - Input: contexto recuperado + pregunta usuario
   - Output: respuesta natural y amigable

### Estrategia de Coordinaci√≥n de Agentes

#### **Modelo de Orquestaci√≥n Autom√°tica vs Manual**

**üéØ Recomendaci√≥n: Orquestaci√≥n H√≠brida**

1. **Decisiones Arquitect√≥nicas**: Manual (t√∫ decides)
2. **Implementaci√≥n de Fases**: Autom√°tica (architect-master coordina)
3. **Tasks espec√≠ficas**: Autom√°tica (cada agente especializado)

```typescript
// Ejemplo de workflow autom√°tico
interface PhaseWorkflow {
  phase: number;
  coordinator: 'architect-master';
  agents: {
    dbmaster: 'schema_creation';
    document_processor: 'extraction_pipeline';
    embedding_master: 'vector_generation';
    ui_guardian: 'user_testing';
  };
  decision_points: 'manual_approval_required'[];
}
```

## FASE 1: Fundaci√≥n y Almacenamiento de Documentos (2-3 semanas)

### Objetivos

‚úÖ Esquema de base de datos completo
‚úÖ Sistema de upload de archivos b√°sico
‚úÖ Gesti√≥n de metadatos
‚úÖ Interfaz de administraci√≥n de documentos

### 1.1 Esquema de Base de Datos

```sql
-- Tabla principal de documentos (multi-tenant)
CREATE TABLE documents (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID REFERENCES organizations(id) NOT NULL,
  community_id UUID REFERENCES communities(id),
  name TEXT NOT NULL,
  file_path TEXT NOT NULL,
  file_size BIGINT NOT NULL,
  mime_type TEXT NOT NULL,
  file_hash TEXT NOT NULL, -- Para detectar duplicados
  document_type TEXT CHECK (document_type IN ('acta', 'factura', 'comunicado', 'contrato', 'presupuesto')),
  processing_status TEXT DEFAULT 'pending' CHECK (processing_status IN ('pending', 'processing', 'completed', 'error')),
  uploaded_by UUID REFERENCES auth.users(id) NOT NULL,
  upload_date TIMESTAMPTZ DEFAULT NOW(),
  processed_at TIMESTAMPTZ,
  metadata_json JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tabla de chunks extra√≠dos para RAG
CREATE TABLE document_chunks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  document_id UUID REFERENCES documents(id) ON DELETE CASCADE,
  organization_id UUID REFERENCES organizations(id) NOT NULL,
  chunk_index INTEGER NOT NULL,
  content TEXT NOT NULL,
  token_count INTEGER,
  metadata_json JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tabla de embeddings vectoriales
CREATE TABLE document_embeddings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  chunk_id UUID REFERENCES document_chunks(id) ON DELETE CASCADE,
  organization_id UUID REFERENCES organizations(id) NOT NULL,
  embedding VECTOR(768), -- Gemini embedding dimension
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Configuraci√≥n organizacional para IA
CREATE TABLE organization_ai_config (
  organization_id UUID REFERENCES organizations(id) PRIMARY KEY,
  gemini_api_key TEXT, -- Encrypted
  max_documents INTEGER DEFAULT 1000,
  max_storage_gb INTEGER DEFAULT 10,
  embedding_model TEXT DEFAULT 'text-embedding-004',
  processing_enabled BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tablas de datos estructurados extra√≠dos por IA
CREATE TABLE extracted_minutes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  document_id UUID REFERENCES documents(id) ON DELETE CASCADE,
  organization_id UUID REFERENCES organizations(id) NOT NULL,
  president_in TEXT,
  president_out TEXT,
  administrator TEXT,
  summary TEXT,
  decisions JSONB,
  meeting_date DATE,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE extracted_invoices (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  document_id UUID REFERENCES documents(id) ON DELETE CASCADE,
  organization_id UUID REFERENCES organizations(id) NOT NULL,
  provider_name TEXT,
  client_name TEXT,
  amount DECIMAL(12,2),
  invoice_date DATE,
  category TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

### 1.2 RLS Policies (Multi-tenant Security)

```sql
-- Policies para documents
CREATE POLICY "organization_isolation_documents"
ON documents FOR ALL
USING (organization_id = get_user_organization_id());

-- Policies para chunks y embeddings
CREATE POLICY "organization_isolation_chunks"
ON document_chunks FOR ALL
USING (organization_id = get_user_organization_id());
```

### Entregables Fase 1

- [ ] **dbmaster-supabase**: Migraci√≥n schema completo (documents, agents, extracted\_\*)
- [ ] **architect-master**: P√°gina `/documents` funcional con upload
- [ ] **dbmaster-supabase**: RLS policies multi-tenant implementadas
- [ ] **architect-master**: Agentes SaaS base configurados en BD

### Responsabilidades (Fase 1)

**üîß Agentes Claude Code:**

- **architect-master**: Coordina implementaci√≥n, desarrolla UI b√°sica
- **dbmaster-supabase**: Migraciones BD, RLS, optimizaciones
- **ui-guardian**: Testing workflows de upload/gesti√≥n documentos
- **deployment-master**: Deploy cada milestone a producci√≥n

**ü§ñ Agentes SaaS:**

- Los agentes de procesamiento se configuran en BD pero a√∫n no se usan

## FASE 2: Pipeline de Procesamiento IA (3-4 semanas)

### Objetivos

‚úÖ Extracci√≥n autom√°tica de texto
‚úÖ Chunking inteligente
‚úÖ Generaci√≥n de embeddings con Gemini
‚úÖ Sistema de colas para procesamiento

### 2.1 Sistema de Procesamiento con Agentes SaaS

```typescript
// Server Action que usa los agentes SaaS
async function processDocument(documentId: string) {
  // 1. Extraer texto del PDF (pdf-parse/mammoth)
  const documentText = await extractText(filePath);

  // 2. Usar agente 'document_classifier' para determinar tipo
  const documentType = await callSaasAgent('document_classifier', {
    document_text: documentText,
  });

  // 3. Usar agente espec√≠fico seg√∫n tipo (ej: 'minutes_extractor')
  const extractedData = await callSaasAgent(`${documentType}_extractor`, {
    document_text: documentText,
  });

  // 4. Guardar datos estructurados
  await saveExtractedData(documentType, extractedData);

  // 5. Chunking y embeddings
  const chunks = await chunkText(documentText);
  const embeddings = await generateEmbeddings(chunks);
  await saveEmbeddings(documentId, embeddings);
}
```

### 2.2 Configuraci√≥n de Agentes SaaS

```sql
-- Insertar prompts espec√≠ficos en tabla agents
INSERT INTO agents (name, purpose, prompt_template, variables) VALUES
('document_classifier',
 'Clasificar tipo de documento',
 'Clasifica este documento en una categor√≠a: acta, factura, comunicado, contrato, presupuesto.

Texto: {document_text}

Responde solo con la categor√≠a.',
 '{"input_key": "document_text", "output_type": "string"}');
```

### Entregables Fase 2

- [ ] **architect-master**: Server Actions usando agentes SaaS
- [ ] **dbmaster-supabase**: Agentes SaaS configurados con prompts
- [ ] **architect-master**: Pipeline extracci√≥n + clasificaci√≥n funcionando
- [ ] **ui-guardian**: UI mostrando progreso y resultados procesamiento

## FASE 3: B√∫squeda Vectorial y RAG (4-5 semanas)

### 3.1 Motor de B√∫squeda Vectorial (embedding-master)

```sql
-- Funci√≥n de b√∫squeda por similitud (dbmaster-supabase)
CREATE OR REPLACE FUNCTION search_documents(
  query_embedding VECTOR(768),
  org_id UUID,
  community_id UUID DEFAULT NULL,
  similarity_threshold FLOAT DEFAULT 0.7,
  max_results INT DEFAULT 20
)
RETURNS TABLE (
  document_id UUID,
  chunk_content TEXT,
  similarity_score FLOAT,
  document_name TEXT
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    dc.document_id,
    dc.content,
    1 - (de.embedding <=> query_embedding) as similarity,
    d.name
  FROM document_embeddings de
  JOIN document_chunks dc ON de.chunk_id = dc.id
  JOIN documents d ON dc.document_id = d.id
  WHERE de.organization_id = org_id
    AND (community_id IS NULL OR d.community_id = search_documents.community_id)
    AND 1 - (de.embedding <=> query_embedding) > similarity_threshold
  ORDER BY similarity DESC
  LIMIT max_results;
END;
$$ LANGUAGE plpgsql;
```

### 3.2 Sistema RAG (rag-coordinator)

```typescript
// Agente rag-coordinator responsable
interface RAGPipeline {
  queryAnalysis: {
    agent: 'Gemini Flash 1.5';
    extractFilters: ['community', 'document_type', 'date_range'];
    enrichQuery: boolean;
  };

  contextRetrieval: {
    vectorSearch: 'embedding-master';
    structuredQuery: 'dbmaster-supabase';
    hybridRanking: 'rag-coordinator';
  };

  responseGeneration: {
    model: 'Gemini Flash 1.5';
    contextWindow: '1M tokens';
    streaming: true;
  };
}
```

### Entregables Fase 3

- [ ] **embedding-master**: B√∫squeda vectorial operativa
- [ ] **rag-coordinator**: RAG endpoints funcionando
- [ ] **ui-guardian**: Interface de b√∫squeda implementada
- [ ] **architect-master**: M√©tricas de relevancia visibles

## FASE 4: Chat Interface y Funcionalidades Avanzadas (3-4 semanas)

### 4.1 Chat Interface (ui-guardian + rag-coordinator)

```typescript
interface ChatSystem {
  frontend: {
    agent: 'ui-guardian';
    features: ['streaming_responses', 'message_history', 'source_citations'];
  };

  backend: {
    agent: 'rag-coordinator';
    features: ['session_management', 'context_retention', 'cost_tracking'];
  };
}
```

### Entregables Fase 4

- [ ] **ui-guardian**: Chat interface completamente funcional
- [ ] **rag-coordinator**: Sistema de sesiones implementado
- [ ] **architect-master**: Funcionalidades de colaboraci√≥n b√°sicas
- [ ] **deployment-master**: Dashboard de analytics operativo

## Cronograma y Coordinaci√≥n

### Metodolog√≠a de Trabajo

#### **1. ¬øQu√© decides T√ö manualmente?**

- ‚úÖ Aprobaci√≥n de cada fase antes de continuar
- ‚úÖ Cambios arquitect√≥nicos mayores
- ‚úÖ Priorizaci√≥n de features
- ‚úÖ Configuraci√≥n de API keys y credenciales

#### **2. ¬øQu√© decide architect-master autom√°ticamente?**

- ‚úÖ Asignaci√≥n de tareas espec√≠ficas a agentes
- ‚úÖ Orden de implementaci√≥n dentro de cada fase
- ‚úÖ Coordinaci√≥n entre agentes especializados
- ‚úÖ Resoluci√≥n de conflictos t√©cnicos menores

#### **3. Workflow de Fase T√≠pico**

```mermaid
sequenceDiagram
    You->>architect-master: Aprobar Fase N
    architect-master->>dbmaster: Crear schemas
    architect-master->>document-processor: Implementar extracci√≥n
    architect-master->>ui-guardian: Desarrollar interfaz
    architect-master->>deployment-master: Deploy a staging
    architect-master->>You: Fase N completada, aprobar siguiente?
```

## Cronograma General

| Fase   | Duraci√≥n      | Agente L√≠der       | Milestone               |
| ------ | ------------- | ------------------ | ----------------------- |
| Fase 1 | Semanas 1-3   | dbmaster-supabase  | Upload y gesti√≥n b√°sica |
| Fase 2 | Semanas 4-7   | document-processor | Pipeline IA completo    |
| Fase 3 | Semanas 8-12  | rag-coordinator    | RAG funcional           |
| Fase 4 | Semanas 13-16 | ui-guardian        | Sistema completo        |

**Total: 16 semanas (4 meses)**

## Pr√≥ximos Pasos Inmediatos

### 1. **¬øQu√© hacer PRIMERO?**

**Mi recomendaci√≥n como architect-master:**

```bash
# OPCI√ìN A: Empezar por DB Foundation (Recomendado)
1. dbmaster-supabase ‚Üí Crear schema Fase 1
2. ui-guardian ‚Üí P√°gina b√°sica /documents
3. deployment-master ‚Üí Deploy y validar

# OPCI√ìN B: Validar producci√≥n actual primero
1. deployment-master ‚Üí Verificar deploy actual
2. ui-guardian ‚Üí Testing completo de funcionalidad existente
3. Luego proceder con Fase 1
```

### 2. **Configuraci√≥n de Nuevos Agentes**

```json
// .claude/document-processor.json (Pendiente crear)
{
  "name": "document-processor",
  "description": "PDF processing and text extraction specialist",
  "tools": ["pdf-parse", "mammoth", "file-upload"],
  "model": "claude-3-5-sonnet-20241022"
}
```

### 3. **Decisi√≥n Clave: ¬øProceder con Fase 1 o Deploy primero?**

**Recomiendo:** Validar deploy actual ‚Üí Luego Fase 1

**Raz√≥n:** Tener una base estable antes de a√±adir complejidad del RAG system.

---

## Respuesta a tus Preguntas Espec√≠ficas

### **1. ¬øQu√© deber√≠a hacer primero?**

**R:** Validar deploy actual con deployment-master, luego iniciar Fase 1 con dbmaster-supabase.

### **2. ¬øDeber√≠a tener un agente arquitecto?**

**R:** ‚úÖ Ya tienes architect-master configurado. Debe coordinar pero t√∫ tomas decisiones arquitect√≥nicas mayores.

### **3. ¬øEs mejor que decida yo o autom√°tico?**

**R:** **H√≠brido** - T√∫ decides el QU√â (estrategia, fases), architect-master decide el C√ìMO (implementaci√≥n, coordinaci√≥n).

### **4. ¬øQu√© agentes faltan?**

**R:** Necesitas 3 agentes nuevos especializados:

- `document-processor` (extracci√≥n de texto)
- `embedding-master` (vectorizaci√≥n)
- `rag-coordinator` (chat inteligente)

---

ü§ñ **Generado por Claude Code - Architect Master Agent**  
üìÖ **Fecha**: 2025-01-11  
üìã **Versi√≥n**: 1.1 (Corregida con stack real + Gemini)  
üéØ **Estado**: Listo para aprobaci√≥n de Fase 1
