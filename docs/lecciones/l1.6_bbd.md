# PROPUESTA INCIAL

## TABLAS

ğŸ›ï¸ Modelo de Datos Adaptado: Gestor de Comunidades
ğŸ‘¥ Tabla: users (Usuarios)
id â†’ Identificador Ãºnico
email â†’ Email del usuario
name â†’ Nombre completo
created_at â†’ Fecha de registro
updated_at â†’ Ãšltima actualizaciÃ³n

ğŸ¡ Tabla: communities (Comunidades)
id â†’ Identificador Ãºnico
name â†’ Nombre de la comunidad (ej: "Comunidad C/Mayor, 5")
address â†’ DirecciÃ³n de la comunidad
created_at â†’ Fecha de creaciÃ³n

ğŸ”— Tabla: user_communities (Tabla de relaciÃ³n)
user_id â†’ Conecta con users.id
community_id â†’ Conecta con communities.id
role â†’ Rol del usuario en la comunidad ("administrador", "residente", etc.)

ğŸ“„ Tabla: documents (Documentos)
id â†’ Identificador Ãºnico
community_id â†’ Conecta con communities.id (Â¡Importante!)
filename â†’ Nombre original del archivo
file_path â†’ DÃ³nde estÃ¡ guardado
file_size â†’ TamaÃ±o en bytes
file_hash â†’ Hash del contenido del archivo (para detectar duplicados)
document_type â†’ "acta", "factura", "comunicado", "contrato", "presupuesto"
status â†’ "processing", "completed", "error"
created_at â†’ CuÃ¡ndo se subiÃ³
processed_at â†’ CuÃ¡ndo terminÃ³ el procesamiento

ğŸ“Š Tablas de Datos EspecÃ­ficos
ğŸ“„ Tabla: extracted_minutes (Datos de Actas)
id â†’ Identificador Ãºnico
document_id â†’ Conecta con documents.id
president_in â†’ Nombre del presidente entrante
president_out â†’ Nombre del presidente saliente
administrator â†’ Nombre del administrador
summary â†’ Resumen del acta
decisions â†’ Decisiones tomadas (JSON o texto)

ğŸ’° Tabla: extracted_invoices (Datos de Facturas)
id â†’ Identificador Ãºnico
document_id â†’ Conecta con documents.id
provider_name â†’ Nombre del proveedor
client_name â†’ Nombre del cliente
amount â†’ Importe
invoice_date â†’ Fecha de la factura
category â†’ CategorÃ­a (ej: "electricidad", "mantenimiento")

ğŸ“œ Tabla: extracted_contracts (Datos de Contratos)
id â†’ Identificador Ãºnico
document_id â†’ Conecta con documents.id
contract_party â†’ Nombre de la parte contratada (ej. "Proveedor de servicios X")
start_date â†’ Fecha de inicio del contrato
end_date â†’ Fecha de finalizaciÃ³n del contrato
amount â†’ Importe total o periÃ³dico del contrato
summary â†’ Resumen de las clÃ¡usulas clave

ğŸ“¢ Tabla: extracted_communications (Datos de Comunicados)
id â†’ Identificador Ãºnico
document_id â†’ Conecta con documents.id
subject â†’ Asunto o tÃ­tulo del comunicado
sent_date â†’ Fecha de envÃ­o del comunicado
recipient_type â†’ Tipo de destinatario ("todos los vecinos", "sÃ³lo administradores", etc.)
content_summary â†’ Resumen del contenido del comunicado

ğŸ’¸ Tabla: extracted_budgets (Datos de Presupuestos)
id â†’ Identificador Ãºnico
document_id â†’ Conecta con documents.id
budget_year â†’ AÃ±o del presupuesto
total_income â†’ Ingresos totales
total_expenses â†’ Gastos totales
approved_date â†’ Fecha de aprobaciÃ³n del presupuesto
breakdown â†’ Desglose detallado por categorÃ­as (JSON o texto)

ğŸ¤– Tabla: agents (Agentes de IA)
id â†’ Identificador Ãºnico
name â†’ Nombre del agente (ej. "Lector de Actas", "Identificador de Preguntas")
purpose â†’ DescripciÃ³n de la funciÃ³n del agente
prompt_template â†’ El texto base o "instrucciÃ³n" que se le da a la IA
variables â†’ Variables que el agente necesita para funcionar (JSON)
created_at â†’ CuÃ¡ndo se creÃ³ el registro

ğŸ¯ Tabla: vector_embeddings (Para bÃºsqueda semÃ¡ntica)
id â†’ Identificador Ãºnico
document_id â†’ Conecta con documents.id
content â†’ Texto del chunk
embedding â†’ Vector numÃ©rico
created_at â†’ CuÃ¡ndo se creÃ³

## PORCESOS

ğŸ“ Procesos de Negocio
Proceso 1: Ingesta de Documentos
SelecciÃ³n de Comunidad: El usuario selecciona una comunidad (community_id) a travÃ©s de la interfaz.

Subida y VerificaciÃ³n: El usuario sube un archivo y el sistema genera su hash. Se comprueba en la tabla documents si el archivo (file_hash) ya existe para esa comunidad.

ValidaciÃ³n de Duplicados: Si el archivo ya existe, el proceso se detiene y se notifica al usuario.

ExtracciÃ³n de Texto: El sistema lee el documento y extrae su contenido de texto (document_text).

IdentificaciÃ³n de Tipo: Si no es un duplicado, el Agente de IdentificaciÃ³n de Documento lee el texto extraÃ­do (document_text) y clasifica el archivo basÃ¡ndose en este para determinar su document_type ("acta", "factura", etc.).

ExtracciÃ³n de Datos: El agente lector adecuado (ej. el Lector de Actas o el Lector de Facturas) lee el contenido y extrae la informaciÃ³n relevante. Los datos se usan para rellenar la tabla documents y la tabla especÃ­fica correspondiente.

Chunking y Embedding: El documento (document_text) es dividido en fragmentos de 800 tokens (content). Cada fragmento se convierte en un vector numÃ©rico (embedding) y se guarda en la tabla vector_embeddings, asociado al document_id.

Proceso 2: Consulta de Datos Estructurados
Consulta de Documentos: El usuario puede listar los documentos disponibles de una comunidad especÃ­fica. La consulta se realiza sobre la tabla documents filtrando por community_id.

Consulta por Tipo: Se filtra aÃºn mÃ¡s la consulta por document_type (ej. "actas").

Consulta de Comunidades: El usuario puede ver todas las comunidades disponibles asociadas a su perfil (tabla user_communities).

Consulta de Datos EspecÃ­ficos: El usuario realiza una consulta sobre los datos extraÃ­dos (ej. Â¿quiÃ©n fue el presidente del acta?) que se resuelve con una consulta a las tablas de datos especÃ­ficos (ej. extracted_minutes).

Proceso 3: GestiÃ³n de Comunidades
CreaciÃ³n de Comunidad: El usuario (con el rol adecuado) crea un nuevo registro en la tabla communities.

AsociaciÃ³n de Usuario: Se crea un registro en la tabla user_communities para vincular al usuario que la creÃ³.

Proceso 4: BÃºsqueda SemÃ¡ntica
Consulta SemÃ¡ntica: El usuario introduce una pregunta de lenguaje natural (ej. Â¿QuÃ© se ha gastado en el mantenimiento del jardÃ­n el Ãºltimo aÃ±o?), esta variable se llama pregunta.

AnÃ¡lisis de la Pregunta: El Agente de AnÃ¡lisis de Preguntas es responsable de analizar la pregunta para identificar campos obligatorios (como community), y opcionales (como document_type y rango temporal), estando sesgado a dar la respuesta con la fecha mÃ¡s reciente si no se menciona un dato temporal.

Mejora de la Pregunta: La pregunta es enriquecida con los datos recopilados por el Agente de AnÃ¡lisis de Preguntas antes de la vectorizaciÃ³n. La variable resultante se llama pregunta_enriquecida.

VectorizaciÃ³n: La pregunta_enriquecida se convierte en un vector numÃ©rico. La variable resultante se llama embedding_pregunta.

BÃºsqueda y RecuperaciÃ³n: El Agente de RecuperaciÃ³n de Datos busca los embeddings mÃ¡s similares a embedding_pregunta en la tabla vector_embeddings, aplicando los filtros identificados. Los resultados se guardan en la variable chunks_relevantes.

GeneraciÃ³n de Respuesta: La informaciÃ³n recuperada en chunks_relevantes se pasa al Agente de ConversaciÃ³n, que genera una respuesta final para el usuario.

Proceso 5: Consulta a travÃ©s del Chat
Inicio de ConversaciÃ³n: El usuario hace una pregunta al chat. La variable se llama pregunta.

AnÃ¡lisis de la Pregunta: El Agente de AnÃ¡lisis de Preguntas analiza la pregunta, identifica si la respuesta podrÃ­a estar en la base de datos estructurada y extrae los filtros necesarios (comunidad, tipo de documento, etc.). Los hallazgos se guardan en la variable analisis_pregunta.

Mejora de la Pregunta: La pregunta es enriquecida con los datos recopilados por el Agente de AnÃ¡lisis de Preguntas. La variable resultante se llama pregunta_enriquecida.

BÃºsqueda de Datos Estructurados: El sistema hace una consulta a la base de datos estructurada con los filtros de analisis_pregunta. Si se encuentra la informaciÃ³n, se recupera. La variable se llama datos_estructurados.

BÃºsqueda SemÃ¡ntica (si es necesario): Si los datos no se encontraron en el paso anterior o la pregunta requiere una bÃºsqueda semÃ¡ntica, el Agente de RecuperaciÃ³n de Datos busca los 20 chunks mÃ¡s relevantes en la tabla vector_embeddings, aplicando los filtros de analisis_pregunta. Los resultados se guardan en la variable chunks_relevantes.

CombinaciÃ³n de Datos: La informaciÃ³n recuperada (tanto los datos_estructurados como los chunks_relevantes) se combina para crear un contexto completo. La variable se llama contexto_completo.

GeneraciÃ³n de Respuesta: El Agente de ConversaciÃ³n toma el contexto_completo y la pregunta_enriquecida original del usuario para generar una respuesta coherente y amigable. La variable se llama respuesta_final.

## AGENTES

DefiniciÃ³n de Agentes y sus Prompts
A continuaciÃ³n, se define la configuraciÃ³n de cada agente para la tabla agents.

1. Agente de IdentificaciÃ³n de Documento
   PropÃ³sito: Analizar un documento para determinar su tipo (acta, factura, comunicado, contrato, presupuesto) y clasificarlo en consecuencia.

prompt_template:

Eres un clasificador de documentos para una comunidad de propietarios. Tu tarea es analizar el texto de un documento y clasificarlo en una de las siguientes categorÃ­as: 'acta', 'factura', 'comunicado', 'contrato' o 'presupuesto'. Devuelve Ãºnicamente el nombre de la categorÃ­a, sin explicaciones ni texto adicional.

Texto del documento: {document_text}

variables:

{
"input_key": "document_text",
"output_type": "string"
}

2. Agente Lector de Actas
   PropÃ³sito: Extraer los datos estructurados clave de un acta de comunidad para rellenar la tabla extracted_minutes.

prompt_template:

Eres un asistente experto en analizar actas de comunidades. Extrae la siguiente informaciÃ³n del texto proporcionado, devolviÃ©ndola en un formato JSON estricto: presidente entrante, presidente saliente, administrador, un resumen conciso y un listado de las decisiones tomadas.

Texto del acta: {document_text}

variables:

{
"input_key": "document_text",
"output_format": "json"
}

3. Agente Lector de Facturas
   PropÃ³sito: Extraer los datos estructurados clave de una factura para rellenar la tabla extracted_invoices.

prompt_template:

Eres un asistente que lee facturas. Extrae los siguientes datos del texto, devolviÃ©ndolos en formato JSON: nombre del proveedor, nombre del cliente, importe total, fecha de la factura y categorÃ­a de gasto (por ejemplo, 'electricidad'). Si algÃºn dato no se encuentra, usa null.

Texto de la factura: {document_text}

variables:

{
"input_key": "document_text",
"output_format": "json"
}

4. Agente Lector de Contratos
   PropÃ³sito: Extraer los datos estructurados clave de un contrato para rellenar la tabla extracted_contracts.

prompt_template:

Eres un asistente que lee contratos. Extrae los siguientes datos del texto, devolviÃ©ndolos en formato JSON: nombre de la parte contratada, fecha de inicio y finalizaciÃ³n del contrato, importe total o periÃ³dico, y un resumen de las clÃ¡usulas. Si algÃºn dato no se encuentra, usa null.

Texto del contrato: {document_text}

variables:

{
"input_key": "document_text",
"output_format": "json"
}

5. Agente Lector de Comunicados
   PropÃ³sito: Extraer los datos estructurados clave de un comunicado para rellenar la tabla extracted_communications.

prompt_template:

Eres un asistente que lee comunicados. Extrae los siguientes datos del texto, devolviÃ©ndolos en formato JSON: el asunto, la fecha de envÃ­o, el tipo de destinatario ('todos los vecinos', 'sÃ³lo administradores', etc.), y un resumen conciso del contenido. Si algÃºn dato no se encuentra, usa null.

Texto del comunicado: {document_text}

variables:

{
"input_key": "document_text",
"output_format": "json"
}

6. Agente Lector de Presupuestos
   PropÃ³sito: Extraer los datos estructurados clave de un presupuesto para rellenar la tabla extracted_budgets.

prompt_template:

Eres un asistente que lee presupuestos. Extrae los siguientes datos del texto, devolviÃ©ndolos en formato JSON: aÃ±o del presupuesto, total de ingresos, total de gastos, fecha de aprobaciÃ³n y un desglose detallado. Si algÃºn dato no se encuentra, usa null.

Texto del presupuesto: {document_text}

variables:

{
"input_key": "document_text",
"output_format": "json"
}

7. Agente de AnÃ¡lisis de Preguntas
   PropÃ³sito: Analizar la pregunta del usuario para identificar la intenciÃ³n, filtros de bÃºsqueda y determinar si se trata de una consulta de datos estructurados o una bÃºsqueda semÃ¡ntica.

prompt_template:

Eres un agente especializado en entender preguntas de lenguaje natural y convertirlas en parÃ¡metros de bÃºsqueda. Analiza la siguiente pregunta para identificar: 1) si la pregunta requiere datos estructurados (por ejemplo, 'presidente del acta'), 2) si se puede responder con una bÃºsqueda semÃ¡ntica (ej. 'Â¿QuÃ© se decidiÃ³ sobre el tejado?'), 3) el tipo de documento ('acta', 'factura', etc.) si se menciona, y 4) el rango de tiempo si se menciona ('Ãºltimo aÃ±o'). Devuelve un JSON con tus hallazgos.

Pregunta: {user_query}

variables:

{
"input_key": "user_query",
"output_format": "json"
}

8. Agente de RecuperaciÃ³n de Datos
   PropÃ³sito: Buscar y recuperar la informaciÃ³n relevante de las tablas (vector_embeddings y otras tablas de datos estructurados) utilizando una estrategia de bÃºsqueda hÃ­brida (keyword + semÃ¡ntica) y un sistema de ranking Top K, aplicando los filtros y el embedding de la pregunta proporcionados.

prompt_template:

Eres un motor de bÃºsqueda y recuperaciÃ³n. Tu tarea es recuperar los datos mÃ¡s relevantes para responder una pregunta, basÃ¡ndote en la consulta vectorizada y los filtros proporcionados. Si la bÃºsqueda es semÃ¡ntica, recupera los fragmentos de texto mÃ¡s similares. Si es una consulta estructurada, recupera los datos de las tablas correspondientes.

InformaciÃ³n de la consulta: {search_query}

variables:

{
"input_key": "search_query",
"output_format": "json"
}

9. Agente de ConversaciÃ³n
   PropÃ³sito: Generar una respuesta coherente y conversacional para el usuario, usando la informaciÃ³n estructurada o los fragmentos de texto (chunks) recuperados de la base de datos.

prompt_template:

Eres un asistente conversacional para un gestor de comunidades. Tu tarea es responder a las preguntas de los usuarios de forma clara y amigable, utilizando la siguiente informaciÃ³n recuperada de la base de datos. Si la informaciÃ³n no es suficiente, indÃ­calo.

InformaciÃ³n recuperada: {retrieved_data}
Pregunta del usuario: {pregunta_enriquecida}

variables:

{
"input_keys": ["retrieved_data", "pregunta_enriquecida"],
"output_format": "string"
}

# COMENTARIOS

ğŸ¯ Excelente arquitectura - Como arquitecto, veo un diseÃ±o muy sÃ³lido. Te doy mi anÃ¡lisis y recomendaciÃ³n de
implementaciÃ³n:

ğŸ“Š Mi EvaluaciÃ³n como Arquitecto

âœ… Fortalezas del DiseÃ±o

1. SeparaciÃ³n clara: Documentos vs datos extraÃ­dos
2. Escalabilidad: Vector embeddings + datos estructurados
3. Multi-tenancy: Todo vinculado a community_id
4. Flexibilidad: Sistema de agentes configurable

âš ï¸ Puntos de Mejora

1. user_communities duplica user_roles - Ya tienes este sistema
2. Complejidad inicial - 12+ tablas es mucho para empezar

ğŸš€ Mi RecomendaciÃ³n: ImplementaciÃ³n Incremental

# VALIDACION

Â¿CÃ³mo validar cada fase?

FASE â†’ Implementar â†’ Probar con usuarios reales â†’ Iterar â†’ Siguiente fase

# multi-tenancy

ğŸ—ï¸ Arquitectura Multi-tenant Correcta

Tienes razÃ³n - el diseÃ±o actual no es Ã³ptimo. Para un SaaS real necesitas:

ğŸ¯ Estructura Correcta:

ORGANIZATION (Administrador de Fincas)
â”œâ”€â”€ COMMUNITY 1
â”‚ â”œâ”€â”€ Vecino A, Vecino B, Vecino C
â”‚ â””â”€â”€ Proveedor X, Proveedor Y
â”œâ”€â”€ COMMUNITY 2
â”‚ â”œâ”€â”€ Vecino D, Vecino E
â”‚ â””â”€â”€ Proveedor Z
â””â”€â”€ COMMUNITY 3
â””â”€â”€ ...

ğŸš« MALO - Tablas por tenant:

-- âŒ Esto NO escala y es pesadilla de mantenimiento
communities_admin1
communities_admin2
users_admin1
users_admin2

âœ… BUENO - Single Database Multi-tenant:

-- âœ… Todas las tablas compartidas con tenant_id
organizations (admin de fincas)
â”œâ”€â”€ communities (organization_id)
â”œâ”€â”€ users (organization_id)
â”œâ”€â”€ incidents (organization_id, community_id)
â””â”€â”€ documents (organization_id, community_id)

ğŸ¯ Ventajas:

1. âœ… Escalabilidad: Una BD para miles de administradoras
2. âœ… Isolation: Cada admin solo ve sus datos
3. âœ… Cost-effective: No duplicar infraestructura
4. âœ… Maintenance: Una sola versiÃ³n de cÃ³digo
5. âœ… Analytics: Datos agregados posibles

# HABILITAR AGENTE DE BASE DE DATOS

## MCP SUPABASE

- Donde esta -->
- el MCP \\wsl.localhost\Ubuntu\home\sergi\proyectos\community-saas\.mcp.json
- .config/claude/claude_desktop_config.json

ConfiguraciÃ³n estÃ¡ correcta:

- Server: @modelcontextprotocol/server-postgres
- DATABASE_URL: Conecta directamente a tu Supabase PostgreSQL
- Credentials: Incluye usuario postgres y contraseÃ±a

## CREAR EL AGENTE

- en CLI mirar `/agents` .claude\dbmaster-supabase.json

# ğŸ¯ Siguiente Paso: DEPLOY

Â¿Por quÃ© deploy primero?

1. Validar Arquitectura Real

- Tu multi-tenancy con organizations estÃ¡ implementado âœ…
- Sistema de permisos funciona âœ…
- Base sÃ³lida probada en local âœ…
- Necesitas validar en producciÃ³n ANTES de aÃ±adir complejidad

2. Feedback Loop Temprano

- Los usuarios reales te dirÃ¡n quÃ© necesitan
- Puedes iterar rÃ¡pidamente sobre funcionalidad bÃ¡sica
- Evitas sobreingenierÃ­a prematura

3. FundaciÃ³n SÃ³lida

- Tienes un MVP funcional multi-tenant
- Adding RAG/documents sobre una base inestable = problema
- Deploy exitoso = confianza para siguientes features

ğŸš€ Plan Recomendado:

AHORA: Deploy & Validar
â”œâ”€â”€ 1. Deploy a Vercel/producciÃ³n
â”œâ”€â”€ 2. Probar flujo completo real
â”œâ”€â”€ 3. Documentar issues de producciÃ³n
â””â”€â”€ 4. Fix crÃ­ticos si los hay

DESPUÃ‰S: IteraciÃ³n incremental
â”œâ”€â”€ 5. Document ingestion system
â”œâ”€â”€ 6. RAG/AI chat implementation
â””â”€â”€ 7. UI/UX refinements

ğŸ¯ Â¿Por quÃ© NO empezar con documents ahora?

Tu diseÃ±o de L1.6 es brillante pero:

- 12+ tablas nuevas es gran salto
- RAG requiere vectorizaciÃ³n estable
- Sin validar base, puedes pivotar despuÃ©s

ğŸ—ï¸ Arquitectura Incremental Correcta:

Fase Actual âœ…: Organizations + Communities + Incidents
Fase 2: Documents + Basic Upload
Fase 3: AI Agents + RAG
Fase 4: Advanced UI/UX

# CREAR AGENTE DE DEPLOY
